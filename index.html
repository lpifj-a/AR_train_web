<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <!-- 横画面を推奨する設定 -->
  <meta name="screen-orientation" content="landscape">
  <meta name="x5-orientation" content="landscape">
  <meta name="msapplication-orientation" content="landscape">
  <title>窓ARアプリ</title>
  <!-- Three.jsを使用した簡易AR -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600&display=swap');
    
    :root {
      --apple-blue: #007AFF;
      --apple-blue-dark: #0062CC;
      --apple-gray: #8E8E93;
      --apple-background: #000000;
      --apple-text: #FFFFFF;
      --apple-secondary: rgba(255, 255, 255, 0.7);
      --apple-button-radius: 22px;
      --apple-blur: 10px;
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: fixed;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      touch-action: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background-color: #000;
    }
    
    /* 縦画面時の警告メッセージ */
    .orientation-message {
      position: fixed;
      display: none;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      padding: 20px;
    }
    
    .orientation-message img {
      width: 120px;
      height: auto;
      margin-bottom: 20px;
      animation: rotate 2s infinite ease-in-out;
    }
    
    @keyframes rotate {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(-90deg); }
      50% { transform: rotate(-90deg); }
      75% { transform: rotate(0deg); }
      100% { transform: rotate(0deg); }
    }
    
    @media (orientation: portrait) {
      .orientation-message {
        display: flex;
      }
    }
    
    #videoElement {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
    }
    
    #gameCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .ui-container {
      position: fixed;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    .menu-btn {
      position: absolute;
      top: max(20px, env(safe-area-inset-top));
      left: max(20px, env(safe-area-inset-left));
      width: 40px;
      height: 40px;
      background-color: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(var(--apple-blur));
      -webkit-backdrop-filter: blur(var(--apple-blur));
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--apple-text);
      font-size: 1.2em;
      pointer-events: all;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .menu-btn:active {
      transform: scale(0.95);
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .start-screen {
      position: fixed;
      width: 100%;
      height: 100%;
      background-color: var(--apple-background);
      background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.95));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      color: var(--apple-text);
      transition: opacity 0.5s cubic-bezier(0.23, 1, 0.32, 1);
      padding: 20px;
    }
    
    .logo {
      margin-bottom: 40px;
      text-align: center;
    }
    
    .logo h1 {
      font-size: 2.8em;
      font-weight: 600;
      letter-spacing: -0.02em;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #007AFF, #5AC8FA);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .logo p {
      font-size: 1.1em;
      font-weight: 400;
      color: var(--apple-secondary);
      margin-top: 0;
      max-width: 80%;
      margin-left: auto;
      margin-right: auto;
    }
    
    .start-btn {
      padding: 12px 24px;
      background-color: var(--apple-blue);
      color: white;
      border: none;
      border-radius: var(--apple-button-radius);
      font-size: 1.1em;
      font-weight: 500;
      cursor: pointer;
      margin: 8px;
      width: 200px;
      text-align: center;
      transition: all 0.2s ease;
      letter-spacing: -0.01em;
    }
    
    .start-btn:active {
      transform: scale(0.98);
      background-color: var(--apple-blue-dark);
    }
    
    .hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(25, 25, 25, 0.9);
      backdrop-filter: blur(var(--apple-blur));
      -webkit-backdrop-filter: blur(var(--apple-blur));
      color: var(--apple-text);
      padding: 30px;
      border-radius: 16px;
      z-index: 30;
      text-align: center;
      max-width: 85%;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }
    
    .modal h2 {
      font-weight: 500;
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.4em;
    }
    
    .modal p {
      color: var(--apple-secondary);
      line-height: 1.5;
      margin-bottom: 20px;
    }
    
    .modal-btn {
      padding: 12px 24px;
      background-color: var(--apple-blue);
      color: white;
      border: none;
      border-radius: var(--apple-button-radius);
      font-weight: 500;
      width: 80%;
      font-size: 1.1em;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 10px;
    }
    
    .modal-btn:active {
      transform: scale(0.98);
      background-color: var(--apple-blue-dark);
    }
    
    .modal-btn.cancel {
      background-color: rgba(150, 150, 150, 0.3);
      color: var(--apple-text);
    }
    
    .modal-btn.cancel:active {
      background-color: rgba(150, 150, 150, 0.5);
    }
    
    .modal-buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    
    /* マインクラフト風コントロール */
    .mc-controls {
      position: fixed;
      bottom: max(20px, env(safe-area-inset-bottom));
      left: 0;
      width: 100%;
      height: 150px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      padding: 0 20px;
      box-sizing: border-box;
    }
    
    /* ジョイスティック */
    .joystick-container {
      width: 120px;
      height: 120px;
      pointer-events: all;
      position: relative;
      touch-action: none;
    }
    
    .joystick-base {
      width: 120px;
      height: 120px;
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(var(--apple-blur));
      -webkit-backdrop-filter: blur(var(--apple-blur));
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .joystick-stick {
      width: 50px;
      height: 50px;
      background-color: rgba(255, 255, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.05s linear;
    }
    
    /* ジャンプボタン */
    .jump-btn {
      width: 80px;
      height: 80px;
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(var(--apple-blur));
      -webkit-backdrop-filter: blur(var(--apple-blur));
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--apple-text);
      font-size: 2em;
      pointer-events: all;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    
    .jump-btn:active {
      background-color: rgba(255, 255, 255, 0.1);
      transform: scale(0.95);
    }
    
    /* ダブルジャンプインジケーター */
    .double-jump-indicator {
      position: absolute;
      bottom: 180px;
      right: 20px;
      background-color: rgba(0, 122, 255, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9em;
      pointer-events: none;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(var(--apple-blur));
      -webkit-backdrop-filter: blur(var(--apple-blur));
    }
    
    /* モバイル最適化 */
    @media (max-width: 767px) {
      .joystick-container {
        width: 100px;
        height: 100px;
      }
      
      .joystick-base {
        width: 100px;
        height: 100px;
      }
      
      .joystick-stick {
        width: 40px;
        height: 40px;
      }
      
      .jump-btn {
        width: 70px;
        height: 70px;
      }
    }
    
    /* 横向き対応 */
    @media (orientation: landscape) {
      .mc-controls {
        height: 100px;
      }
      
      .joystick-container {
        width: 90px;
        height: 90px;
      }
      
      .joystick-base {
        width: 90px;
        height: 90px;
      }
      
      .joystick-stick {
        width: 35px;
        height: 35px;
      }
      
      .jump-btn {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <!-- 縦画面向け警告メッセージ -->
  <div class="orientation-message" id="orientationMessage">
    <div class="rotate-icon">↺</div>
    <h2>横画面でプレイしてください</h2>
    <!-- <p>最高の体験を得るためにデバイスを横向きにしてください</p> -->
  </div>
  
  <!-- カメラビデオフィード -->
  <video id="videoElement" autoplay playsinline></video>
  
  <!-- Three.jsのレンダリングキャンバス -->
  <canvas id="gameCanvas"></canvas>

  <!-- スタート画面 -->
  <div class="start-screen" id="startScreen">
    <div class="logo">
      <h1>車窓AR</h1>
      <p>電車窓の風景を舞台に、ARでキャラクターを操作しよう</p>
    </div>
    <button class="start-btn" id="startBtn">プレイする</button>
    <!-- <button class="start-btn" id="settingsBtn">設定</button> -->
    <!-- <button class="start-btn" id="tutorialBtn">チュートリアル</button> -->
  </div>

  <!-- カメラアクセス許可モーダル (必要に応じて表示) -->
  <div class="modal hidden" id="cameraModal">
    <h2>カメラへのアクセス</h2>
    <p>このアプリはカメラを使用してARエクスペリエンスを提供します。</p>
    <p>ブラウザの許可ダイアログで「許可」を選択してください。</p>
    <button class="modal-btn" id="cameraPermissionBtn">了解</button>
  </div>

  <!-- 確認ポップアップモーダル -->
  <div class="modal hidden" id="confirmModal">
    <h2>ゲームを終了しますか？</h2>
    <p>スタート画面に戻ります。</p>
    <div class="modal-buttons">
      <button class="modal-btn" id="confirmYesBtn">はい、終了します</button>
      <button class="modal-btn cancel" id="confirmNoBtn">いいえ、続けます</button>
    </div>
  </div>

  <!-- UI コントロール -->
  <div class="ui-container">
    <div class="menu-btn" id="menuBtn">≡</div>
    
    <!-- マインクラフト風操作コントロール -->
    <div class="mc-controls">
      <!-- 左側：移動ジョイスティック -->
      <div class="joystick-container" id="joystickContainer">
        <div class="joystick-base">
          <div class="joystick-stick" id="joystickStick"></div>
        </div>
      </div>
      
      <!-- 右側：ジャンプボタン -->
      <div class="jump-btn" id="jumpBtn">
        <div class="jump-icon">↑</div>
      </div>
    </div>
    
    <!-- ダブルジャンプ関連UI -->
    <div id="doubleJumpIndicator" class="double-jump-indicator hidden">
      ダブルジャンプ可能！
    </div>
  </div>

  <script>
    // ゲーム関連の変数
    let isGameStarted = false;
    let ninjaPosition = { x: 0, y: 0, z: -2 };
    let ninjaVelocity = { x: 0, y: 0, z: 0 };
    let isJumping = false;
    let canDoubleJump = false;
    let hasDoubleJumped = false;
    let lastJumpTime = 0;
    const doubleJumpTimeWindow = 500; // ダブルジャンプが可能な時間枠（ミリ秒）
    const gravity = 0.01;
    const jumpForce = 0.30; // 基本ジャンプ力
    const doubleJumpForce = 0.28; // 二段階ジャンプ力
    const moveSpeed = 0.1;
    const groundLevel = -1.5;
    let animationFrameId = null;
    
    // Three.js関連の変数
    let scene, camera, renderer;
    let ninja;
    let videoElement, videoTexture;
    
    // ジョイスティック関連
    let joystickActive = false;
    let joystickStartPos = { x: 0, y: 0 };
    let joystickCurrentPos = { x: 0, y: 0 };
    const joystickMaxDistance = 40; // ジョイスティックの最大移動距離
    
    // 入力状態を追跡するためのフラグ
    let isMovingLeft = false;
    let isMovingRight = false;
    let touchIdentifiers = {
      joystick: null,
      jumpButton: null
    };
    
    // 画面方向
    let isLandscape = false;
    
    // DOM要素の参照を格納する変数
    let startScreen, startBtn, settingsBtn, tutorialBtn, menuBtn;
    let jumpBtn, joystickContainer, joystickStick;
    let cameraModal, cameraPermissionBtn, doubleJumpIndicator;
    let orientationMessage, confirmModal, confirmYesBtn, confirmNoBtn;
    
    // DOM要素の参照を初期化する関数
    function initDOMElements() {
      startScreen = document.getElementById('startScreen');
      startBtn = document.getElementById('startBtn');
      settingsBtn = document.getElementById('settingsBtn');
      tutorialBtn = document.getElementById('tutorialBtn');
      menuBtn = document.getElementById('menuBtn');
      jumpBtn = document.getElementById('jumpBtn');
      joystickContainer = document.getElementById('joystickContainer');
      joystickStick = document.getElementById('joystickStick');
      cameraModal = document.getElementById('cameraModal');
      cameraPermissionBtn = document.getElementById('cameraPermissionBtn');
      doubleJumpIndicator = document.getElementById('doubleJumpIndicator');
      orientationMessage = document.getElementById('orientationMessage');
      confirmModal = document.getElementById('confirmModal');
      confirmYesBtn = document.getElementById('confirmYesBtn');
      confirmNoBtn = document.getElementById('confirmNoBtn');
    }
    
    // カメラアクセスを初期化
    function initCamera() {
      videoElement = document.getElementById('videoElement');
      
      // 画面を横向きに固定
      lockScreenOrientation();
      
      // 現在の画面方向を確認
      checkOrientation();
      
      // カメラへのアクセス許可を要求
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        // カメラの方向設定
        const constraints = {
          video: {
            facingMode: 'environment',
            width: { ideal: window.innerWidth },
            height: { ideal: window.innerHeight }
          }
        };
        
        navigator.mediaDevices.getUserMedia(constraints)
          .then(function(stream) {
            videoElement.srcObject = stream;
            // カメラ向きを設定
            setVideoOrientation(stream);
            
            videoElement.onloadedmetadata = function() {
              videoElement.play();
              initThreeJS();
            };
          })
          .catch(function(error) {
            console.error('カメラへのアクセスエラー:', error);
            // カメラアクセス許可モーダルを表示
            cameraModal.classList.remove('hidden');
          });
      } else {
        console.error('getUserMedia未対応のブラウザです');
        alert('お使いのブラウザはカメラ機能に対応していません。別のブラウザをお試しください。');
      }
    }
    
    // 画面方向を確認
    function checkOrientation() {
      isLandscape = window.innerWidth > window.innerHeight;
      
      // 縦画面の場合は警告メッセージを表示
      if (!isLandscape) {
        orientationMessage.style.display = 'flex';
      } else {
        orientationMessage.style.display = 'none';
      }
    }
    
    // カメラのストリームを適切な向きに設定
    function setVideoOrientation(stream) {
      if (!stream) return;
      
      const videoTracks = stream.getVideoTracks();
      if (videoTracks.length === 0) return;
      
      const track = videoTracks[0];
      const settings = track.getSettings();
      
      // 可能であれば向きを設定（一部のブラウザでは機能しない場合あり）
      if ('aspectRatio' in settings) {
        const newConstraints = {
          aspectRatio: { ideal: 16/9 } // 常に横向きアスペクト比を設定
        };
        
        track.applyConstraints(newConstraints)
          .catch(error => console.warn('カメラの向き設定エラー:', error));
      }
    }
    
    // Three.js環境の初期化
    function initThreeJS() {
      // シーンの作成
      scene = new THREE.Scene();
      
      // カメラの作成
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      camera.position.y = 1;
      
      // レンダラーの作成
      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('gameCanvas'),
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      
      // 子供キャラクターの作成
      createCharacter();
      
      // 光源の追加
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 10, 10);
      scene.add(directionalLight);
      
      // リサイズイベントの設定
      window.addEventListener('resize', onWindowResize, false);
    }
    
    // ウィンドウリサイズ時の処理
    // ウィンドウリサイズ時の処理 - 強化バージョン
    function onWindowResize() {
      const wasLandscape = isLandscape;
      const oldWidth = window.innerWidth;
      const oldHeight = window.innerHeight;
      
      checkOrientation();
      
      // サイズと向き両方が大幅に変化した場合のみ再初期化
      // 単純なリサイズ操作で完全再初期化が何度も呼ばれないように閾値を設定
      if (wasLandscape !== isLandscape) {
        // 向きが変わった場合は常に再初期化
        console.log('リサイズによる向きの変更を検出: ' + (isLandscape ? '横向き' : '縦向き'));
        reinitializeCamera();
      } else {
        // 向きが変わらない場合は通常のリサイズ処理のみ
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }
    }
    
    // 子供キャラクターの作成（より丁寧なバージョン）
    function createCharacter() {
      // キャラクターグループの作成
      ninja = new THREE.Group();

      // 体全体の色を定義
      const skinColor = 0xffddbb;      // 肌色
      const shirtColor = 0x4287f5;     // 明るい青色
      const pantsColor = 0x3a3a3a;     // 濃いグレー
      const shoeColor = 0x222222;      // 黒に近いグレー
      const hairColor = 0x8B4513;      // 茶色
      
      // 子供の本体（胴体）- 厚みのあるTシャツ
      const bodyGeometry = new THREE.BoxGeometry(0.5, 0.6, 0.25);
      const bodyMaterial = new THREE.MeshPhongMaterial({ 
        color: shirtColor,
        shininess: 10  // 服の質感
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.05;
      
      // シャツの襟元
      const collarGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.26);
      const collarMaterial = new THREE.MeshPhongMaterial({ color: 0x3273dc });
      const collar = new THREE.Mesh(collarGeometry, collarMaterial);
      collar.position.set(0, 0.33, 0);
      
      // 頭 - より楕円に近い形状に
      const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
      const headMaterial = new THREE.MeshPhongMaterial({
        color: skinColor,
        shininess: 30  // 肌の質感
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 0.6;
      head.scale.set(0.9, 1.1, 0.9);  // 少し縦長の頭
      
      // 左腕上部 (肩から肘)
      const upperLeftArmGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.25, 8);
      const armMaterial = new THREE.MeshPhongMaterial({ color: shirtColor }); // Tシャツと同じ色
      const upperLeftArm = new THREE.Mesh(upperLeftArmGeometry, armMaterial);
      upperLeftArm.position.set(-0.32, 0.2, 0);
      upperLeftArm.rotation.z = -Math.PI * 0.1; // 少し腕を曲げる
      
      // 左腕下部 (肘から手首)
      const lowerLeftArmGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.25, 8);
      const lowerArmMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
      const lowerLeftArm = new THREE.Mesh(lowerLeftArmGeometry, lowerArmMaterial);
      lowerLeftArm.position.set(-0.40, 0.05, 0);
      lowerLeftArm.rotation.z = -Math.PI * 0.15;
      
      // 左手
      const leftHandGeometry = new THREE.SphereGeometry(0.04, 8, 8);
      const handMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
      const leftHand = new THREE.Mesh(leftHandGeometry, handMaterial);
      leftHand.position.set(-0.48, -0.08, 0);
      leftHand.scale.set(1, 0.8, 0.8);
      
      // 右腕上部 (肩から肘)
      const upperRightArmGeometry = new THREE.CylinderGeometry(0.06, 0.05, 0.25, 8);
      const upperRightArm = new THREE.Mesh(upperRightArmGeometry, armMaterial);
      upperRightArm.position.set(0.32, 0.2, 0);
      upperRightArm.rotation.z = Math.PI * 0.1; // 反対方向に曲げる
      
      // 右腕下部 (肘から手首)
      const lowerRightArmGeometry = new THREE.CylinderGeometry(0.05, 0.04, 0.25, 8);
      const lowerRightArm = new THREE.Mesh(lowerRightArmGeometry, lowerArmMaterial);
      lowerRightArm.position.set(0.40, 0.05, 0);
      lowerRightArm.rotation.z = Math.PI * 0.15;
      
      // 右手
      const rightHandGeometry = new THREE.SphereGeometry(0.04, 8, 8);
      const rightHand = new THREE.Mesh(rightHandGeometry, handMaterial);
      rightHand.position.set(0.48, -0.08, 0);
      rightHand.scale.set(1, 0.8, 0.8);
      
      // ズボン - ウエスト部分
      const waistGeometry = new THREE.CylinderGeometry(0.25, 0.2, 0.1, 8);
      const pantsMaterial = new THREE.MeshPhongMaterial({ 
        color: pantsColor,
        shininess: 5  // マットな質感
      });
      const waist = new THREE.Mesh(waistGeometry, pantsMaterial);
      waist.position.y = -0.25;
      
      // ズボン - 太もも部分
      const thighsGeometry = new THREE.BoxGeometry(0.45, 0.2, 0.25);
      const thighs = new THREE.Mesh(thighsGeometry, pantsMaterial);
      thighs.position.y = -0.4;
      
      // 左足 (太もも〜ふくらはぎ)
      const leftLegGeometry = new THREE.CylinderGeometry(0.07, 0.06, 0.3, 8);
      const legMaterial = new THREE.MeshPhongMaterial({ color: pantsColor });
      const leftLeg = new THREE.Mesh(leftLegGeometry, legMaterial);
      leftLeg.position.set(-0.15, -0.6, 0);
      
      // 右足 (太もも〜ふくらはぎ)
      const rightLegGeometry = new THREE.CylinderGeometry(0.07, 0.06, 0.3, 8);
      const rightLeg = new THREE.Mesh(rightLegGeometry, legMaterial);
      rightLeg.position.set(0.15, -0.6, 0);
      
      // 左靴
      const leftShoeGeometry = new THREE.BoxGeometry(0.12, 0.1, 0.18);
      const shoeMaterial = new THREE.MeshPhongMaterial({ 
        color: shoeColor,
        shininess: 30  // 光沢のある靴
      });
      const leftShoe = new THREE.Mesh(leftShoeGeometry, shoeMaterial);
      leftShoe.position.set(-0.15, -0.8, 0.02);
      leftShoe.scale.set(1, 1, 1.2);  // つま先を少し前に
      
      // 右靴
      const rightShoeGeometry = new THREE.BoxGeometry(0.12, 0.1, 0.18);
      const rightShoe = new THREE.Mesh(rightShoeGeometry, shoeMaterial);
      rightShoe.position.set(0.15, -0.8, 0.02);
      rightShoe.scale.set(1, 1, 1.2);  // つま先を少し前に
      
      // 目（左）- より目らしい形状
      const leftEyeGeometry = new THREE.SphereGeometry(0.05, 12, 12);
      const eyesMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xffffff,  // 白目
        shininess: 100
      });
      const leftEye = new THREE.Mesh(leftEyeGeometry, eyesMaterial);
      leftEye.position.set(-0.1, 0.65, 0.18);
      leftEye.scale.set(0.6, 1, 0.6);  // 縦長の目
      
      // 黒目（左）
      const leftPupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
      const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
      const leftPupil = new THREE.Mesh(leftPupilGeometry, pupilMaterial);
      leftPupil.position.set(-0.1, 0.65, 0.22);
      
      // 目（右）
      const rightEyeGeometry = new THREE.SphereGeometry(0.05, 12, 12);
      const rightEye = new THREE.Mesh(rightEyeGeometry, eyesMaterial);
      rightEye.position.set(0.1, 0.65, 0.18);
      rightEye.scale.set(0.6, 1, 0.6);  // 縦長の目
      
      // 黒目（右）
      const rightPupilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
      const rightPupil = new THREE.Mesh(rightPupilGeometry, pupilMaterial);
      rightPupil.position.set(0.1, 0.65, 0.22);
      
      // 眉毛（左）
      const leftEyebrowGeometry = new THREE.BoxGeometry(0.08, 0.02, 0.01);
      const eyebrowMaterial = new THREE.MeshPhongMaterial({ color: hairColor });
      const leftEyebrow = new THREE.Mesh(leftEyebrowGeometry, eyebrowMaterial);
      leftEyebrow.position.set(-0.1, 0.74, 0.23);
      leftEyebrow.rotation.z = Math.PI * 0.05;  // 少し角度をつける
      
      // 眉毛（右）
      const rightEyebrowGeometry = new THREE.BoxGeometry(0.08, 0.02, 0.01);
      const rightEyebrow = new THREE.Mesh(rightEyebrowGeometry, eyebrowMaterial);
      rightEyebrow.position.set(0.1, 0.74, 0.23);
      rightEyebrow.rotation.z = -Math.PI * 0.05;  // 反対方向に傾ける
      
      // 口 - 笑顔
      const mouthGeometry = new THREE.BoxGeometry(0.12, 0.03, 0.01);
      const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0xcc6666 });
      const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
      mouth.position.set(0, 0.52, 0.24);
      
      // 髪の毛（上部）
      const topHairGeometry = new THREE.SphereGeometry(0.25, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
      const hairMaterial = new THREE.MeshPhongMaterial({ 
        color: hairColor,
        shininess: 5  // マットな質感
      });
      const topHair = new THREE.Mesh(topHairGeometry, hairMaterial);
      topHair.position.set(0, 0.73, 0);
      topHair.scale.set(1.1, 0.8, 1.1);
      
      // 前髪
      const frontHairGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.15);
      const frontHair = new THREE.Mesh(frontHairGeometry, hairMaterial);
      frontHair.position.set(0, 0.76, 0.15);
      frontHair.rotation.x = Math.PI * 0.2;
      
      // 側面の髪（左）
      const leftSideHairGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.2);
      const leftSideHair = new THREE.Mesh(leftSideHairGeometry, hairMaterial);
      leftSideHair.position.set(-0.23, 0.6, 0);
      
      // 側面の髪（右）
      const rightSideHairGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.2);
      const rightSideHair = new THREE.Mesh(rightSideHairGeometry, hairMaterial);
      rightSideHair.position.set(0.23, 0.6, 0);

      // キャラクター作成時に各パーツに名前をつける
      upperLeftArm.name = 'upperLeftArm';
      lowerLeftArm.name = 'lowerLeftArm';
      leftHand.name = 'leftHand';
      upperRightArm.name = 'upperRightArm';
      lowerRightArm.name = 'lowerRightArm';
      rightHand.name = 'rightHand';
      leftLeg.name = 'leftLeg';
      rightLeg.name = 'rightLeg';
      leftShoe.name = 'leftShoe';
      rightShoe.name = 'rightShoe';
      
      // キャラクターをグループに追加
      ninja.add(body);
      ninja.add(collar);
      ninja.add(head);
      
      // 腕の追加
      ninja.add(upperLeftArm);
      ninja.add(lowerLeftArm);
      ninja.add(leftHand);
      ninja.add(upperRightArm);
      ninja.add(lowerRightArm);
      ninja.add(rightHand);
      
      // 下半身の追加
      ninja.add(waist);
      ninja.add(thighs);
      ninja.add(leftLeg);
      ninja.add(rightLeg);
      ninja.add(leftShoe);
      ninja.add(rightShoe);
      
      // 顔の詳細パーツの追加
      ninja.add(leftEye);
      ninja.add(leftPupil);
      ninja.add(rightEye);
      ninja.add(rightPupil);
      ninja.add(leftEyebrow);
      ninja.add(rightEyebrow);
      ninja.add(mouth);
      
      // 髪の毛の追加
      ninja.add(topHair);
      ninja.add(frontHair);
      ninja.add(leftSideHair);
      ninja.add(rightSideHair);
      
      // 初期位置の設定
      ninja.position.set(ninjaPosition.x, ninjaPosition.y, ninjaPosition.z);
      
      // シーンに追加
      scene.add(ninja);
    }
    
    // ゲーム開始処理
    function startGame() {
      isGameStarted = true;
      startScreen.classList.add('hidden');
      
      // 画面を横向きに固定
      lockScreenOrientation();
      
      // フルスクリーンモードを試行
      requestFullscreen();
      
      // ゲームループの開始
      animate();
    }

    // ゲーム終了確認ダイアログを表示
    function showExitConfirmation() {
      if (isGameStarted) {
        confirmModal.classList.remove('hidden');
      }
    }

    // スタート画面に戻る処理
    function returnToStartScreen() {
      isGameStarted = false;
      startScreen.classList.remove('hidden');
      confirmModal.classList.add('hidden');
      resetGame();
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }
    
    // 確認ダイアログをキャンセルして、ゲームを継続
    function continueGame() {
      confirmModal.classList.add('hidden');
    }
    
    // ゲームをリセット
    function resetGame() {
      ninjaPosition = { x: 0, y: 0, z: -3 };
      ninjaVelocity = { x: 0, y: 0, z: 0 };
      isJumping = false;
      canDoubleJump = false;
      hasDoubleJumped = false;
      
      // キャラクターの位置をリセット
      if (ninja) {
        ninja.position.set(ninjaPosition.x, ninjaPosition.y, ninjaPosition.z);
        ninja.rotation.set(0, 0, 0);
      }
    }
    
    // フルスクリーンモードをリクエスト
    function requestFullscreen() {
      const doc = window.document;
      const docEl = doc.documentElement;
      
      const requestFullScreen = 
        docEl.requestFullscreen || 
        docEl.mozRequestFullScreen || 
        docEl.webkitRequestFullScreen || 
        docEl.msRequestFullscreen;
      
      if (requestFullScreen && !isFullscreen()) {
        requestFullScreen.call(docEl);
      }
    }
    
    // 現在フルスクリーンかどうかを確認
    function isFullscreen() {
      return !!(
        document.fullscreenElement ||
        document.mozFullScreenElement ||
        document.webkitFullscreenElement ||
        document.msFullscreenElement
      );
    }
    
    // 操作関数
    function jump() {
      if (isGameStarted) {
        const currentTime = Date.now();
        
        if (!isJumping) {
          // 初回ジャンプ
          isJumping = true;
          canDoubleJump = true;
          hasDoubleJumped = false;
          ninjaVelocity.y = jumpForce;
          lastJumpTime = currentTime;
          
          // ダブルジャンプの時間枠を設定
          setTimeout(() => {
            if (canDoubleJump && !hasDoubleJumped) {
              // ダブルジャンプが可能であることを示すインジケーターを表示
              // doubleJumpIndicator.classList.remove('hidden');
              
              // // 3秒後に非表示
              // setTimeout(() => {
              //   doubleJumpIndicator.classList.add('hidden');
              //   canDoubleJump = false;
              // }, 3000);
            }
          }, 100);
        } else if (canDoubleJump && !hasDoubleJumped && 
                  (currentTime - lastJumpTime < doubleJumpTimeWindow)) {
          // ダブルジャンプの実行
          hasDoubleJumped = true;
          canDoubleJump = false;
          ninjaVelocity.y = doubleJumpForce;
          doubleJumpIndicator.classList.add('hidden');
          
          // ダブルジャンプのエフェクト（キャラクターを一瞬回転させる）
          if (ninja) {
            ninja.rotation.z = Math.PI; // 180度回転
            setTimeout(() => {
              ninja.rotation.z = 0; // 回転を戻す
            }, 300);
          }
        }
      }
    }
    
    // ジョイスティック関連の関数
    function initJoystick() {
      // タッチイベント
      joystickContainer.addEventListener('touchstart', handleJoystickStart);
      document.addEventListener('touchmove', handleTouchMove);
      document.addEventListener('touchend', handleTouchEnd);
      document.addEventListener('touchcancel', handleTouchEnd);
      
      // ジャンプボタンのイベント
      jumpBtn.addEventListener('touchstart', handleJumpStart);
      jumpBtn.addEventListener('touchend', handleJumpEnd);
      
      // マウスイベント（デスクトップ対応）
      joystickContainer.addEventListener('mousedown', handleJoystickMouseStart);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      // ジャンプボタンのマウスイベント
      jumpBtn.addEventListener('mousedown', jump);
    }
    
    // ジョイスティックタッチ開始
    function handleJoystickStart(e) {
      if (!isGameStarted) return;
      e.preventDefault();
      
      // マルチタッチ対応のため、このタッチのIDを記録
      const touch = e.changedTouches[0];
      touchIdentifiers.joystick = touch.identifier;
      
      joystickActive = true;
      
      // ジョイスティックの開始位置を記録
      const rect = joystickContainer.getBoundingClientRect();
      joystickStartPos.x = rect.left + rect.width / 2;
      joystickStartPos.y = rect.top + rect.height / 2;
      
      // 現在位置を更新
      joystickCurrentPos.x = touch.clientX;
      joystickCurrentPos.y = touch.clientY;
      
      updateJoystickPosition();
    }
    
    // ジャンプボタンタッチ開始
    function handleJumpStart(e) {
      if (!isGameStarted) return;
      e.preventDefault();
      
      // マルチタッチ対応のため、このタッチのIDを記録
      const touch = e.changedTouches[0];
      touchIdentifiers.jumpButton = touch.identifier;
      
      jump();
    }
    
    // タッチ移動
    function handleTouchMove(e) {
      if (!isGameStarted) return;
      e.preventDefault();
      
      // すべてのタッチについて処理
      for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        
        // ジョイスティック操作のタッチを処理
        if (joystickActive && touch.identifier === touchIdentifiers.joystick) {
          joystickCurrentPos.x = touch.clientX;
          joystickCurrentPos.y = touch.clientY;
          updateJoystickPosition();
        }
      }
    }
    
    // タッチ終了
    function handleTouchEnd(e) {
      if (!isGameStarted) return;
      
      // すべてのタッチについて処理
      for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        
        // ジョイスティック操作のタッチを終了
        if (touch.identifier === touchIdentifiers.joystick) {
          joystickActive = false;
          touchIdentifiers.joystick = null;
          
          // ジョイスティックを中央に戻す
          joystickStick.style.transform = 'translate(-50%, -50%)';
          
          // 移動を停止
          ninjaVelocity.x = 0;
        }
        
        // ジャンプボタンのタッチを終了
        if (touch.identifier === touchIdentifiers.jumpButton) {
          touchIdentifiers.jumpButton = null;
        }
      }
    }
    
    // ジャンプボタンタッチ終了
    function handleJumpEnd(e) {
      if (!isGameStarted) return;
      e.preventDefault();
      
      // ジャンプボタンのタッチを終了
      touchIdentifiers.jumpButton = null;
    }
    
    // マウスでのジョイスティック操作（デスクトップ対応）
    function handleJoystickMouseStart(e) {
      if (!isGameStarted) return;
      e.preventDefault();
      
      joystickActive = true;
      
      // ジョイスティックの開始位置を記録
      const rect = joystickContainer.getBoundingClientRect();
      joystickStartPos.x = rect.left + rect.width / 2;
      joystickStartPos.y = rect.top + rect.height / 2;
      
      // 現在位置を更新
      joystickCurrentPos.x = e.clientX;
      joystickCurrentPos.y = e.clientY;
      
      updateJoystickPosition();
    }
    
    // マウス移動
    function handleMouseMove(e) {
      if (!joystickActive || !isGameStarted) return;
      
      // 現在位置を更新
      joystickCurrentPos.x = e.clientX;
      joystickCurrentPos.y = e.clientY;
      
      updateJoystickPosition();
    }
    
    // マウスボタン解放
    function handleMouseUp() {
      if (!isGameStarted) return;
      
      joystickActive = false;
      
      // ジョイスティックを中央に戻す
      joystickStick.style.transform = 'translate(-50%, -50%)';
      
      // 移動を停止
      ninjaVelocity.x = 0;
    }
    
    // ジョイスティックの位置を更新
    function updateJoystickPosition() {
      if (!joystickActive) return;
      
      // ジョイスティックの移動量を計算
      let deltaX = joystickCurrentPos.x - joystickStartPos.x;
      let deltaY = joystickCurrentPos.y - joystickStartPos.y;
      
      // 移動距離の制限
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (distance > joystickMaxDistance) {
        deltaX = deltaX * joystickMaxDistance / distance;
        deltaY = deltaY * joystickMaxDistance / distance;
      }
      
      // スティックの位置を更新
      joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      
      // 横方向の移動速度を設定（左右のみ対応）
      ninjaVelocity.x = (deltaX / joystickMaxDistance) * moveSpeed * 2;
    }
    
    // キーボード操作のハンドラ
    function handleKeyDown(event) {
      if (!isGameStarted) return;
      
      switch(event.key) {
        case 'ArrowUp':
        case ' ': // スペースキーでもジャンプ可能に
          jump();
          break;
        case 'ArrowLeft':
          ninjaVelocity.x = -moveSpeed;
          isMovingLeft = true;
          break;
        case 'ArrowRight':
          ninjaVelocity.x = moveSpeed;
          isMovingRight = true;
          break;
        case 'ArrowDown':
          // しゃがむアクション（将来実装）
          break;
        case 'f': // フルスクリーン切替
        case 'F':
          requestFullscreen();
          break;
        case 'Escape': // ESCキーでメニューを表示
          showExitConfirmation();
          break;
      }
    }
    
    function handleKeyUp(event) {
      if (!isGameStarted) return;
      
      switch(event.key) {
        case 'ArrowLeft':
          isMovingLeft = false;
          if (!isMovingRight) ninjaVelocity.x = 0;
          else ninjaVelocity.x = moveSpeed;
          break;
        case 'ArrowRight':
          isMovingRight = false;
          if (!isMovingLeft) ninjaVelocity.x = 0;
          else ninjaVelocity.x = -moveSpeed;
          break;
      }
    }
    
    // 物理演算の適用
    function applyPhysics() {
      // 重力の適用
      ninjaVelocity.y -= gravity;
      
      // 位置の更新
      ninjaPosition.x += ninjaVelocity.x;
      ninjaPosition.y += ninjaVelocity.y;
      
      // 地面の衝突判定
      if (ninjaPosition.y < groundLevel) {
        ninjaPosition.y = groundLevel;
        ninjaVelocity.y = 0;
        isJumping = false;
        hasDoubleJumped = false;
        canDoubleJump = false;
        doubleJumpIndicator.classList.add('hidden');
      }
      
      // 画面外に出ないように制限
      if (ninjaPosition.x < -20) ninjaPosition.x = -20;
      if (ninjaPosition.x > 20) ninjaPosition.x = 20;
      
      // キャラクターの位置を更新
      if (ninja) {
        ninja.position.x = ninjaPosition.x;
        ninja.position.y = ninjaPosition.y;
        ninja.position.z = ninjaPosition.z;
      }
    }
    
    // アニメーションループ
    function animate() {
      if (isGameStarted) {
        animationFrameId = requestAnimationFrame(animate);
        
        applyPhysics();
        
        // キャラクターのアニメーション
        // キャラクター固有の配列インデックスを直接使用する方法に戻します
        if (ninja) {
          // 移動の有無で条件分岐
          if (Math.abs(ninjaVelocity.x) > 0.03) {
            // 移動方向に応じて回転
            ninja.rotation.y = ninjaVelocity.x > 0 ? Math.PI * 0.25 : -Math.PI * 0.25;
            
            // 走るアニメーションの基本変数
            const runSpeed = 0.01; // アニメーション速度
            const time = Date.now() * runSpeed;
            
            // 体を少し前傾（走っているような姿勢）
            ninja.rotation.x = 0.15; // より前傾姿勢に
            
            // 左足と右足をより大きく動かす
            const leftLeg = ninja.getObjectByName('leftLeg');
            const rightLeg = ninja.getObjectByName('rightLeg');
            
            if (leftLeg) {
              // 左足の動きを強調（振幅を大きく）
              const leftAngle = Math.cos(time) * 1.2; // 振幅を1.2に増加
              leftLeg.rotation.x = leftAngle;
            }
            
            if (rightLeg) {
              // 右足も強調して逆位相で
              const rightAngle = Math.cos(time + Math.PI) * 1.2;
              rightLeg.rotation.x = rightAngle;
            }
            
            // 靴も強調して足と同じ動き
            const leftShoe = ninja.getObjectByName('leftShoe');
            const rightShoe = ninja.getObjectByName('rightShoe');
            
            if (leftShoe) leftShoe.rotation.x = Math.cos(time) * 0.9; // 振幅を0.9に増加
            if (rightShoe) rightShoe.rotation.x = Math.cos(time + Math.PI) * 0.9;
            
            // 腕も強調して足と逆のタイミングで振る
            const upperLeftArm = ninja.getObjectByName('upperLeftArm');
            const upperRightArm = ninja.getObjectByName('upperRightArm');
            
            if (upperLeftArm) upperLeftArm.rotation.x = Math.cos(time + Math.PI) * 1.0; // 振幅を1.0に増加
            if (upperRightArm) upperRightArm.rotation.x = Math.cos(time) * 1.0;
            
            // 腕の下部（前腕）は上腕と同じ動きに簡略化
            const lowerLeftArm = ninja.getObjectByName('lowerLeftArm');
            const lowerRightArm = ninja.getObjectByName('lowerRightArm');
            
            if (lowerLeftArm) lowerLeftArm.rotation.x = Math.cos(time + Math.PI) * 1.0;
            if (lowerRightArm) lowerRightArm.rotation.x = Math.cos(time) * 1.0;

            // 手のアニメーション - 腕と同様に動かす
          const leftHand = ninja.getObjectByName('leftHand');
          const rightHand = ninja.getObjectByName('rightHand');

          if (leftHand) leftHand.rotation.x = Math.cos(time + Math.PI) * 1.0; // 左腕と同じ動き
          if (rightHand) rightHand.rotation.x = Math.cos(time) * 1.0; // 右腕と同じ動き
            
            // ズボンの太もも部分のアニメーションを強調
            const thighs = ninja.getObjectByName('thighs');
            if (thighs) {
              // より大きな前後の揺れ
              thighs.rotation.x = Math.sin(time * 2) * 0.25; // 振幅を0.25に増加
              // 左右の揺れも大きく
              thighs.rotation.z = Math.sin(time) * 0.15; // 振幅を0.15に増加
            }
            
            // ウエスト部分もより強調
            const waist = ninja.getObjectByName('waist');
            if (waist) {
              waist.rotation.x = Math.sin(time * 2) * 0.1; // 振幅を0.1に増加
            }
            
            // 体全体の上下の動きも強調
            const bounceHeight = Math.abs(Math.sin(time * 2)) * 0.05; // 振幅を0.15に増加
            ninja.position.y = ninjaPosition.y + bounceHeight;
            
          } else {
            // 停止中はデフォルト姿勢に戻す
            ninja.rotation.y = 0;
            ninja.rotation.x = 0;
            
            // 全てのアニメーション中のパーツをリセット
            const partsToReset = [
              'leftLeg', 'rightLeg', 'leftShoe', 'rightShoe', 
              'upperLeftArm', 'upperRightArm', 'lowerLeftArm', 'lowerRightArm',
              'leftHand', 'rightHand', 'thighs', 'waist'
            ];
            
            partsToReset.forEach(partName => {
              const part = ninja.getObjectByName(partName);
              if (part) {
                part.rotation.x = 0;
                part.rotation.z = 0;
              }
            });
            
            // Y位置も元に戻す
            ninja.position.y = ninjaPosition.y;
          }
        }
        
        renderer.render(scene, camera);
      }
    }
    
    // 初期化
    function init() {
      // 画面回転の検出
      window.addEventListener('orientationchange', handleOrientationChange);
      window.addEventListener('resize', onWindowResize);
      
      // DOM要素の参照を取得
      initDOMElements();
      
      // カメラアクセス許可ボタンのイベントリスナー
      cameraPermissionBtn.addEventListener('click', function() {
        cameraModal.classList.add('hidden');
        initCamera();
      });
      
      // スタートボタンのイベントリスナー
      startBtn.addEventListener('click', startGame);

      // スタートに戻るボタン
      menuBtn.addEventListener('click', showExitConfirmation);
      
      // 確認ダイアログのボタン
      confirmYesBtn.addEventListener('click', returnToStartScreen);
      confirmNoBtn.addEventListener('click', continueGame);

      // コントロールの初期化
      initJoystick();

      // キーボード操作のイベントリスナー
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      
      // スクロールを無効化
      document.body.addEventListener('touchmove', function(e) {
        if (e.target.closest('#startScreen') === null) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // 初期の画面方向を確認
      checkOrientation();
      
      // カメラ初期化
      initCamera();
    }


    // ビデオストリームを停止する関数
    // ビデオストリームを停止する関数
    function stopVideoStream() {
      if (videoElement && videoElement.srcObject) {
        const tracks = videoElement.srcObject.getTracks();
        tracks.forEach(track => track.stop());
        videoElement.srcObject = null;
      }
    }

    // カメラとビデオストリーム、キャラクターを完全に再初期化する関数
    function reinitializeCamera() {
      console.log('カメラとビデオストリームを再初期化します...');
      
      // アニメーションを一時停止
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // キャラクター位置をリセット
      ninjaPosition = { x: 0, y: 0, z: -3 };
      ninjaVelocity = { x: 0, y: 0, z: 0 };
      isJumping = false;
      canDoubleJump = false;
      hasDoubleJumped = false;
      
      // 既存のビデオストリームを停止
      stopVideoStream();
      
      // 再初期化中であることを示すフラグ
      let isReinitializing = true;
      
      // 再初期化中のローディングメッセージ表示（オプション）
      // const loadingMessage = document.createElement('div');
      // loadingMessage.textContent = 'カメラを調整中...';
      // loadingMessage.style.position = 'fixed';
      // loadingMessage.style.top = '50%';
      // loadingMessage.style.left = '50%';
      // loadingMessage.style.transform = 'translate(-50%, -50%)';
      // loadingMessage.style.color = 'white';
      // loadingMessage.style.background = 'rgba(0, 0, 0, 0.7)';
      // loadingMessage.style.padding = '10px 20px';
      // loadingMessage.style.borderRadius = '8px';
      // loadingMessage.style.zIndex = '1000';
      // document.body.appendChild(loadingMessage);
      
      // Three.jsの初期化をリセット
      if (ninja) {
        scene.remove(ninja);
        ninja = null; // 明示的に参照をクリア
      }
      
      // 新しいカメラアクセスを初期化
      // 画面を横向きに固定
      lockScreenOrientation();
      
      // カメラへのアクセス許可を要求
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        // カメラの方向設定
        const constraints = {
          video: {
            facingMode: 'environment',
            width: { ideal: window.innerWidth },
            height: { ideal: window.innerHeight }
          }
        };
        
        navigator.mediaDevices.getUserMedia(constraints)
          .then(function(stream) {
            videoElement.srcObject = stream;
            // カメラ向きを設定
            setVideoOrientation(stream);
            
            videoElement.onloadedmetadata = function() {
              videoElement.play();
              
              // Three.jsを再初期化
              // 既存のカメラとレンダラーを再利用する場合
              if (camera && renderer) {
                // カメラのアスペクト比を更新
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                
                // カメラ位置をリセット
                camera.position.set(0, 1, 3);
                
                // レンダラーのサイズを更新
                renderer.setSize(window.innerWidth, window.innerHeight);
              } else {
                // 新規作成が必要な場合
                initThreeJS();
              }
              
              // キャラクターを再作成
              createCharacter();
              
              // キャラクターの位置を明示的に設定
              if (ninja) {
                ninja.position.set(ninjaPosition.x, ninjaPosition.y, ninjaPosition.z);
                ninja.rotation.set(0, 0, 0);
                
                // 個別のパーツの回転もリセット
                if (isGameStarted) {
                  const partsToReset = [
                    'leftLeg', 'rightLeg', 'leftShoe', 'rightShoe', 
                    'upperLeftArm', 'upperRightArm', 'lowerLeftArm', 'lowerRightArm',
                    'leftHand', 'rightHand', 'thighs', 'waist'
                  ];
                  
                  partsToReset.forEach(partName => {
                    const part = ninja.getObjectByName(partName);
                    if (part) {
                      part.rotation.x = 0;
                      part.rotation.z = 0;
                    }
                  });
                }
              }
              
              // 再初期化完了
              isReinitializing = false;
              
              // ローディングメッセージを削除
              // document.body.removeChild(loadingMessage);
              
              // ゲームが開始されていた場合、アニメーションを再開
              if (isGameStarted) {
                animate();
              }
            };
          })
          .catch(function(error) {
            console.error('カメラへのアクセスエラー:', error);
            // 再初期化完了、エラー表示
            isReinitializing = false;
            // document.body.removeChild(loadingMessage);
            
            // カメラアクセス許可モーダルを表示
            cameraModal.classList.remove('hidden');
          });
      } else {
        console.error('getUserMedia未対応のブラウザです');
        alert('お使いのブラウザはカメラ機能に対応していません。別のブラウザをお試しください。');
        isReinitializing = false;
        // document.body.removeChild(loadingMessage);
      }
    }
    
    // 画面回転時の処理 - 強化バージョン
    function handleOrientationChange() {
      // 少し遅延を設けて実行（回転アニメーション中に実行すると正確でない場合がある）
      setTimeout(() => {
        const wasLandscape = isLandscape;
        checkOrientation();
        
        // 向きが変わった場合のみ完全な再初期化を実行
        if (wasLandscape !== isLandscape) {
          console.log('画面の向きが変わりました: ' + (isLandscape ? '横向き' : '縦向き'));
          reinitializeCamera();
        }
      }, 500); // タイミングを少し長めに（300ms→500ms）
    }
    
    // 画面を横向きに固定
    function lockScreenOrientation() {
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape')
          .catch(err => console.warn('画面向きロックエラー:', err));
      }
    }
    
    // 初期化を実行
    window.addEventListener('load', init);
  </script>
</body>
</html>